package codeRequest

import (
	"fmt"
	"log"
	"regexp"
	"strings"

	"github.com/emmahsax/go-git-helper/internal/commandline"
	"github.com/emmahsax/go-git-helper/internal/git"
	"github.com/emmahsax/go-git-helper/internal/githubPullRequest"
	"github.com/emmahsax/go-git-helper/internal/gitlabMergeRequest"
	"github.com/spf13/cobra"
)

type CodeRequest struct{}

func NewCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:                   "code-request",
		Short:                 "Create either a GitHub pull request or a GitLab merge request",
		Args:                  cobra.ExactArgs(0),
		DisableFlagsInUseLine: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			codeRequest().execute()
			return nil
		},
	}

	return cmd
}

func codeRequest() *CodeRequest {
	return &CodeRequest{}
}

func (cr *CodeRequest) execute() {
	if isGitHub() && isGitLab() {
		askForClarification()
	} else if isGitHub() {
		createGitHub()
	} else if isGitLab() {
		createGitLab()
	} else {
		log.Fatal("Could not locate GitHub or GitLab remote URLs")
	}
}

func askForClarification() {
	answer := commandline.AskMultipleChoice("Found git remotes for both GitHub and GitLab. Which would you like to proceed with?", []string{"GitHub", "GitLab"})
	if answer == "GitHub" {
		createGitHub()
	} else {
		createGitLab()
	}
}

func createGitHub() {
	options := make(map[string]string)
	options["baseBranch"] = baseBranch()
	options["newPrTitle"] = newPrTitle()
	options["localBranch"] = git.CurrentBranch()
	options["localRepo"] = git.RepoName()
	githubPullRequest.NewGitHubPullRequest(options).Create()
}

func createGitLab() {
	options := make(map[string]string)
	options["baseBranch"] = baseBranch()
	options["newMrTitle"] = newMrTitle()
	options["localBranch"] = git.CurrentBranch()
	options["localProject"] = git.RepoName()
	gitlabMergeRequest.NewGitLabMergeRequest(options).Create()
}

func baseBranch() string {
	answer := commandline.AskYesNoQuestion("Is '" + git.DefaultBranch() + "' the correct base branch for your new code request?")

	if answer {
		return git.DefaultBranch()
	} else {
		return commandline.AskOpenEndedQuestion("Base branch?", false)
	}
}

func newMrTitle() string {
	return newPrTitle()
}

func newPrTitle() string {
	answer := commandline.AskYesNoQuestion("Accept the autogenerated code request title '" + autogeneratedTitle() + "'?")

	if answer {
		return autogeneratedTitle()
	} else {
		return commandline.AskOpenEndedQuestion("Title?", false)
	}
}

func autogeneratedTitle() string {
	branchArr := strings.FieldsFunc(git.CurrentBranch(), func(r rune) bool {
		return r == '-' || r == '_'
	})

	if len(branchArr) == 0 {
		return ""
	}

	var result string

	if len(branchArr) == 1 {
		result = titleize(branchArr[0])
	} else if checkAllLetters(branchArr[0]) && checkAllNumbers(branchArr[1]) { // Branch includes jira_123 at beginning
		issue := fmt.Sprintf("%s-%s", strings.ToUpper(branchArr[0]), branchArr[1])
		description := strings.Join(branchArr[2:], " ")
		result = fmt.Sprintf("%s %s", issue, titleize(description))
	} else if matchesFullJiraPattern(branchArr[0]) { // Branch includes jira-123 at beginning
		issueSplit := strings.Split(branchArr[0], "-")
		issue := fmt.Sprintf("%s-%s", strings.ToUpper(issueSplit[0]), issueSplit[1])
		description := strings.Join(branchArr[2:], " ")
		result = fmt.Sprintf("%s %s", issue, titleize(description))
	} else {
		result = titleize(strings.Join(branchArr, " "))
	}

	return result
}

func checkAllLetters(s string) bool {
	match, _ := regexp.MatchString("^[a-zA-Z]+$", s)
	return match
}

func checkAllNumbers(s string) bool {
	match, _ := regexp.MatchString("^[0-9]+$", s)
	return match
}

func matchesFullJiraPattern(str string) bool {
	match, _ := regexp.MatchString(`^\w+-\d+$`, str)
	return match
}

func titleize(s string) string {
	if len(s) == 0 {
		return s
	}

	firstChar := strings.ToUpper(string(s[0]))
	return firstChar + s[1:]
}

func isGitHub() bool {
	return containsSubstring(git.Remotes(), "github")
}

func isGitLab() bool {
	return containsSubstring(git.Remotes(), "gitlab")
}

func containsSubstring(strs []string, substring string) bool {
	for _, str := range strs {
		if strings.Contains(str, substring) {
			return true
		}
	}
	return false
}
